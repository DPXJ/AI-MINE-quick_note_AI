# 🔧 快捷键窗口卡死问题 - 修复说明

## ❗ 问题描述

**症状**：
- ✅ 快捷键能触发窗口显示
- ❌ 但窗口显示后无法输入，卡死
- ✅ 通过托盘菜单打开的窗口正常

## 🔍 根本原因

这是典型的 **Qt GUI 线程安全问题**：

1. `pynput` 的快捷键监听在**后台线程**中运行
2. 快捷键回调函数在**监听线程**中执行
3. Qt 的 GUI 操作**必须在主线程**中执行
4. 跨线程直接操作 GUI 导致死锁和卡死

```
pynput 线程 → 直接调用 GUI → ❌ 线程冲突
pynput 线程 → 发射信号 → 主线程处理 → ✅ 线程安全
```

---

## ✅ 修复方案

### 1. 添加 Qt 信号（线程安全通信）

**文件**：`src/main.py`

```python
class QuickNoteApp(QObject):
    # 定义信号（用于线程安全的 GUI 操作）
    show_quick_input_signal = pyqtSignal()
    toggle_clipboard_signal = pyqtSignal()
```

### 2. 连接信号到槽函数

```python
def _connect_signals(self):
    # 线程安全的快捷键信号（从 pynput 线程到主线程）
    self.show_quick_input_signal.connect(self._show_quick_input)
    self.toggle_clipboard_signal.connect(self._toggle_clipboard)
```

### 3. 快捷键回调只发射信号

```python
# 快捷键监听器
self.hotkey_listener.register(
    config.hotkey_quick_input,
    lambda: self.show_quick_input_signal.emit()  # ← 只发射信号
)
```

**执行流程**：
```
按下快捷键 
  → pynput 线程检测到 
  → 发射 Qt 信号 
  → Qt 事件循环接收 
  → 主线程执行 GUI 操作 
  → ✅ 窗口正常显示和输入
```

---

## 🎯 额外优化

### 1. 强制窗口激活（Windows API）

**文件**：`src/gui/quick_input.py`

```python
def show_at_center(self):
    # ... 原有代码 ...
    
    # 在 Windows 上强制激活窗口
    try:
        import ctypes
        hwnd = int(self.winId())
        ctypes.windll.user32.SetForegroundWindow(hwnd)
    except:
        pass
```

**作用**：确保窗口能抢占焦点，即使其他应用在前台。

### 2. 窗口保持在顶层

```python
self.setWindowFlags(
    Qt.FramelessWindowHint |
    Qt.Window |
    Qt.WindowStaysOnTopHint  # ← 保持在顶层
)
```

**作用**：快捷键调用时，窗口始终显示在最前面。

### 3. 双重聚焦保险

```python
QTimer.singleShot(50, lambda: self.text_edit.setFocus())
QTimer.singleShot(100, lambda: self.text_edit.setFocus())
```

**作用**：延迟聚焦，确保窗口完全激活后再聚焦输入框。

---

## 📋 修改的文件

### 1. `src/main.py` - 主程序
- ✅ 添加线程安全信号
- ✅ 修改快捷键回调为信号发射
- ✅ 连接信号到槽函数

### 2. `src/gui/quick_input.py` - 输入窗口
- ✅ 添加 Windows API 强制激活
- ✅ 窗口标志添加 WindowStaysOnTopHint
- ✅ 优化聚焦时机

---

## 🚀 验证修复

### 重新打包并测试

```bash
# 1. 清理旧文件
rmdir /s /q build dist

# 2. 重新打包
pyinstaller build.spec

# 3. 以管理员运行
右键 QuickNote_AI.exe → 以管理员身份运行

# 4. 测试快捷键
按 Ctrl+Shift+Space → 窗口显示 → 可以正常输入 ✅
```

### 测试清单

- [ ] 按快捷键，窗口是否显示？
- [ ] 窗口显示后，能否立即输入文字？
- [ ] 按 Enter 能否提交内容？
- [ ] 按 Esc 能否关闭窗口？
- [ ] 托盘菜单打开窗口是否也正常？
- [ ] 切换到其他应用后，快捷键是否仍然有效？

---

## 💡 技术细节

### Qt 信号槽机制的线程安全

Qt 的信号槽默认是 **队列连接**（Queued Connection）：
- 信号在发射线程中立即返回
- 信号参数被放入事件队列
- 槽函数在接收对象的线程中执行

这样就实现了线程安全的跨线程通信。

### 为什么托盘菜单没问题？

托盘图标的菜单点击事件本身就在 **Qt 主线程**中：
```
用户点击菜单 
  → Qt 事件循环检测 
  → 主线程执行槽函数 
  → ✅ 直接操作 GUI 是安全的
```

而快捷键是在 pynput 的**独立监听线程**中：
```
pynput 线程 
  → 直接调用 GUI ❌ 
  → 需要通过信号转发到主线程 ✅
```

---

## 🔧 类似问题的通用解决方案

如果遇到其他 GUI 跨线程操作问题，也可以用相同方法：

1. **定义信号**
```python
my_signal = pyqtSignal(str, int)  # 可以带参数
```

2. **在其他线程发射信号**
```python
def thread_callback():
    self.my_signal.emit("data", 123)
```

3. **在主线程接收信号**
```python
self.my_signal.connect(self.handle_in_main_thread)
```

---

## 📚 参考资料

- [Qt Signals and Slots](https://doc.qt.io/qt-5/signalsandslots.html)
- [Qt Thread Basics](https://doc.qt.io/qt-5/thread-basics.html)
- [pynput Documentation](https://pynput.readthedocs.io/)

---

**修复完成！现在重新打包即可解决卡死问题。** 🎉

